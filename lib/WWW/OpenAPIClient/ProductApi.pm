=begin comment

API2Cart OpenAPI

API2Cart

The version of the OpenAPI document: 1.1
Contact: contact@api2cart.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::ProductApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# product_add
#
# product.add
#
# @param ProductAdd $product_add  (required)
{
    my $params = {
    'product_add' => {
        data_type => 'ProductAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_add' } = {
        summary => 'product.add',
        params => $params,
        returns => 'ProductAdd200Response',
        };
}
# @return ProductAdd200Response
#
sub product_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_add' is set
    unless (exists $args{'product_add'}) {
      croak("Missing the required parameter 'product_add' when calling product_add");
    }

    # parse inputs
    my $_resource_path = '/product.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_add'}) {
        $_body_data = $args{'product_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductAdd200Response', $response);
    return $_response_object;
}

#
# product_add_batch
#
# product.add.batch
#
# @param ProductAddBatch $product_add_batch  (required)
{
    my $params = {
    'product_add_batch' => {
        data_type => 'ProductAddBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_add_batch' } = {
        summary => 'product.add.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub product_add_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'product_add_batch' is set
    unless (exists $args{'product_add_batch'}) {
      croak("Missing the required parameter 'product_add_batch' when calling product_add_batch");
    }

    # parse inputs
    my $_resource_path = '/product.add.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_add_batch'}) {
        $_body_data = $args{'product_add_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

#
# product_attribute_list
#
# product.attribute.list
#
# @param string $product_id Retrieves attributes specified by product id (required)
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param string $attribute_id Retrieves info for specified attribute_id (optional)
# @param string $variant_id Defines product&#39;s variants specified by variant id (optional)
# @param string $attribute_group_id Filter by attribute_group_id (optional)
# @param string $lang_id Retrieves attributes specified by language id (optional)
# @param string $store_id Retrieves attributes specified by store id (optional)
# @param string $set_name Retrieves attributes specified by set_name in Magento (optional)
# @param string $sort_by Set field to sort by (optional, default to 'attribute_id')
# @param string $sort_direction Set sorting direction (optional, default to 'asc')
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'attribute_id,name')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Retrieves attributes specified by product id',
        required => '1',
    },
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'attribute_id' => {
        data_type => 'string',
        description => 'Retrieves info for specified attribute_id',
        required => '0',
    },
    'variant_id' => {
        data_type => 'string',
        description => 'Defines product&#39;s variants specified by variant id',
        required => '0',
    },
    'attribute_group_id' => {
        data_type => 'string',
        description => 'Filter by attribute_group_id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Retrieves attributes specified by language id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves attributes specified by store id',
        required => '0',
    },
    'set_name' => {
        data_type => 'string',
        description => 'Retrieves attributes specified by set_name in Magento',
        required => '0',
    },
    'sort_by' => {
        data_type => 'string',
        description => 'Set field to sort by',
        required => '0',
    },
    'sort_direction' => {
        data_type => 'string',
        description => 'Set sorting direction',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_attribute_list' } = {
        summary => 'product.attribute.list',
        params => $params,
        returns => 'ModelResponseProductAttributeList',
        };
}
# @return ModelResponseProductAttributeList
#
sub product_attribute_list {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_attribute_list");
    }

    # parse inputs
    my $_resource_path = '/product.attribute.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'attribute_id'}) {
        $query_params->{'attribute_id'} = $self->{api_client}->to_query_value($args{'attribute_id'});
    }

    # query params
    if ( exists $args{'variant_id'}) {
        $query_params->{'variant_id'} = $self->{api_client}->to_query_value($args{'variant_id'});
    }

    # query params
    if ( exists $args{'attribute_group_id'}) {
        $query_params->{'attribute_group_id'} = $self->{api_client}->to_query_value($args{'attribute_group_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'set_name'}) {
        $query_params->{'set_name'} = $self->{api_client}->to_query_value($args{'set_name'});
    }

    # query params
    if ( exists $args{'sort_by'}) {
        $query_params->{'sort_by'} = $self->{api_client}->to_query_value($args{'sort_by'});
    }

    # query params
    if ( exists $args{'sort_direction'}) {
        $query_params->{'sort_direction'} = $self->{api_client}->to_query_value($args{'sort_direction'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductAttributeList', $response);
    return $_response_object;
}

#
# product_attribute_value_set
#
# product.attribute.value.set
#
# @param string $product_id Defines product id where the attribute should be added (required)
# @param string $attribute_id Filter by attribute_id (optional)
# @param string $attribute_group_id Filter by attribute_group_id (optional)
# @param string $attribute_name Define attribute name (optional)
# @param string $value Define attribute value (optional)
# @param int $value_id Define attribute value id (optional)
# @param string $lang_id Language id (optional)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the attribute should be added',
        required => '1',
    },
    'attribute_id' => {
        data_type => 'string',
        description => 'Filter by attribute_id',
        required => '0',
    },
    'attribute_group_id' => {
        data_type => 'string',
        description => 'Filter by attribute_group_id',
        required => '0',
    },
    'attribute_name' => {
        data_type => 'string',
        description => 'Define attribute name',
        required => '0',
    },
    'value' => {
        data_type => 'string',
        description => 'Define attribute value',
        required => '0',
    },
    'value_id' => {
        data_type => 'int',
        description => 'Define attribute value id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_attribute_value_set' } = {
        summary => 'product.attribute.value.set',
        params => $params,
        returns => 'ProductAttributeValueSet200Response',
        };
}
# @return ProductAttributeValueSet200Response
#
sub product_attribute_value_set {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_attribute_value_set");
    }

    # parse inputs
    my $_resource_path = '/product.attribute.value.set.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'attribute_id'}) {
        $query_params->{'attribute_id'} = $self->{api_client}->to_query_value($args{'attribute_id'});
    }

    # query params
    if ( exists $args{'attribute_group_id'}) {
        $query_params->{'attribute_group_id'} = $self->{api_client}->to_query_value($args{'attribute_group_id'});
    }

    # query params
    if ( exists $args{'attribute_name'}) {
        $query_params->{'attribute_name'} = $self->{api_client}->to_query_value($args{'attribute_name'});
    }

    # query params
    if ( exists $args{'value'}) {
        $query_params->{'value'} = $self->{api_client}->to_query_value($args{'value'});
    }

    # query params
    if ( exists $args{'value_id'}) {
        $query_params->{'value_id'} = $self->{api_client}->to_query_value($args{'value_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductAttributeValueSet200Response', $response);
    return $_response_object;
}

#
# product_attribute_value_unset
#
# product.attribute.value.unset
#
# @param string $product_id Product id (required)
# @param string $attribute_id Attribute Id (required)
# @param string $store_id Store Id (optional)
# @param boolean $include_default Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
# @param boolean $reindex Is reindex required (optional, default to true)
# @param boolean $clear_cache Is cache clear required (optional, default to true)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Product id',
        required => '1',
    },
    'attribute_id' => {
        data_type => 'string',
        description => 'Attribute Id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'include_default' => {
        data_type => 'boolean',
        description => 'Boolean, whether or not to unset default value of the attribute, if applicable',
        required => '0',
    },
    'reindex' => {
        data_type => 'boolean',
        description => 'Is reindex required',
        required => '0',
    },
    'clear_cache' => {
        data_type => 'boolean',
        description => 'Is cache clear required',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_attribute_value_unset' } = {
        summary => 'product.attribute.value.unset',
        params => $params,
        returns => 'ProductAttributeValueUnset200Response',
        };
}
# @return ProductAttributeValueUnset200Response
#
sub product_attribute_value_unset {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_attribute_value_unset");
    }

    # verify the required parameter 'attribute_id' is set
    unless (exists $args{'attribute_id'}) {
      croak("Missing the required parameter 'attribute_id' when calling product_attribute_value_unset");
    }

    # parse inputs
    my $_resource_path = '/product.attribute.value.unset.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'attribute_id'}) {
        $query_params->{'attribute_id'} = $self->{api_client}->to_query_value($args{'attribute_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'include_default'}) {
        $query_params->{'include_default'} = $self->{api_client}->to_query_value($args{'include_default'});
    }

    # query params
    if ( exists $args{'reindex'}) {
        $query_params->{'reindex'} = $self->{api_client}->to_query_value($args{'reindex'});
    }

    # query params
    if ( exists $args{'clear_cache'}) {
        $query_params->{'clear_cache'} = $self->{api_client}->to_query_value($args{'clear_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductAttributeValueUnset200Response', $response);
    return $_response_object;
}

#
# product_brand_list
#
# product.brand.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param string $brand_ids Retrieves brands specified by brand ids (optional)
# @param string $category_id Retrieves product brands specified by category id (optional)
# @param string $parent_id Retrieves brands specified by parent id (optional)
# @param string $store_id Store Id (optional)
# @param string $lang_id Language id (optional)
# @param string $find_where Entity search that is specified by the comma-separated unique fields (optional)
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,short_description,active,url')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'brand_ids' => {
        data_type => 'string',
        description => 'Retrieves brands specified by brand ids',
        required => '0',
    },
    'category_id' => {
        data_type => 'string',
        description => 'Retrieves product brands specified by category id',
        required => '0',
    },
    'parent_id' => {
        data_type => 'string',
        description => 'Retrieves brands specified by parent id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Entity search that is specified by the comma-separated unique fields',
        required => '0',
    },
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_brand_list' } = {
        summary => 'product.brand.list',
        params => $params,
        returns => 'ModelResponseProductBrandList',
        };
}
# @return ModelResponseProductBrandList
#
sub product_brand_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.brand.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'brand_ids'}) {
        $query_params->{'brand_ids'} = $self->{api_client}->to_query_value($args{'brand_ids'});
    }

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'parent_id'}) {
        $query_params->{'parent_id'} = $self->{api_client}->to_query_value($args{'parent_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductBrandList', $response);
    return $_response_object;
}

#
# product_child_item_find
#
# product.child_item.find
#
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $find_where Entity search that is specified by the comma-separated unique fields (optional)
# @param string $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
# @param string $store_id Store Id (optional)
{
    my $params = {
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Entity search that is specified by the comma-separated unique fields',
        required => '0',
    },
    'find_params' => {
        data_type => 'string',
        description => 'Entity search that is specified by comma-separated parameters',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_child_item_find' } = {
        summary => 'product.child_item.find',
        params => $params,
        returns => 'ProductChildItemFind200Response',
        };
}
# @return ProductChildItemFind200Response
#
sub product_child_item_find {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.child_item.find.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'find_params'}) {
        $query_params->{'find_params'} = $self->{api_client}->to_query_value($args{'find_params'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductChildItemFind200Response', $response);
    return $_response_object;
}

#
# product_child_item_info
#
# product.child_item.info
#
# @param string $product_id Filter by parent product id (required)
# @param string $id Entity id (required)
# @param string $store_id Store Id (optional)
# @param string $lang_id Language id (optional)
# @param string $currency_id Currency Id (optional)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
# @param boolean $use_latest_api_version Use the latest platform API version (optional, default to false)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Filter by parent product id',
        required => '1',
    },
    'id' => {
        data_type => 'string',
        description => 'Entity id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'currency_id' => {
        data_type => 'string',
        description => 'Currency Id',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    'use_latest_api_version' => {
        data_type => 'boolean',
        description => 'Use the latest platform API version',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_child_item_info' } = {
        summary => 'product.child_item.info',
        params => $params,
        returns => 'ProductChildItemInfo200Response',
        };
}
# @return ProductChildItemInfo200Response
#
sub product_child_item_info {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_child_item_info");
    }

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_child_item_info");
    }

    # parse inputs
    my $_resource_path = '/product.child_item.info.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'currency_id'}) {
        $query_params->{'currency_id'} = $self->{api_client}->to_query_value($args{'currency_id'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    # query params
    if ( exists $args{'use_latest_api_version'}) {
        $query_params->{'use_latest_api_version'} = $self->{api_client}->to_query_value($args{'use_latest_api_version'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductChildItemInfo200Response', $response);
    return $_response_object;
}

#
# product_child_item_list
#
# product.child_item.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param string $product_id Filter by parent product id (optional)
# @param string $product_ids Filter by parent product ids (optional)
# @param string $sku Filter by products variant&#39;s sku (optional)
# @param string $store_id Store Id (optional)
# @param string $lang_id Language id (optional)
# @param string $currency_id Currency Id (optional)
# @param boolean $avail_sale Specifies the set of available/not available products for sale (optional)
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $find_where Child products search that is specified by field (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param boolean $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
# @param string $report_request_id Report request id (optional)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
# @param boolean $use_latest_api_version Use the latest platform API version (optional, default to false)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Filter by parent product id',
        required => '0',
    },
    'product_ids' => {
        data_type => 'string',
        description => 'Filter by parent product ids',
        required => '0',
    },
    'sku' => {
        data_type => 'string',
        description => 'Filter by products variant&#39;s sku',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'currency_id' => {
        data_type => 'string',
        description => 'Currency Id',
        required => '0',
    },
    'avail_sale' => {
        data_type => 'boolean',
        description => 'Specifies the set of available/not available products for sale',
        required => '0',
    },
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Child products search that is specified by field',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'return_global' => {
        data_type => 'boolean',
        description => 'Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned.',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    'use_latest_api_version' => {
        data_type => 'boolean',
        description => 'Use the latest platform API version',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_child_item_list' } = {
        summary => 'product.child_item.list',
        params => $params,
        returns => 'ModelResponseProductChildItemList',
        };
}
# @return ModelResponseProductChildItemList
#
sub product_child_item_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.child_item.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'product_ids'}) {
        $query_params->{'product_ids'} = $self->{api_client}->to_query_value($args{'product_ids'});
    }

    # query params
    if ( exists $args{'sku'}) {
        $query_params->{'sku'} = $self->{api_client}->to_query_value($args{'sku'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'currency_id'}) {
        $query_params->{'currency_id'} = $self->{api_client}->to_query_value($args{'currency_id'});
    }

    # query params
    if ( exists $args{'avail_sale'}) {
        $query_params->{'avail_sale'} = $self->{api_client}->to_query_value($args{'avail_sale'});
    }

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'return_global'}) {
        $query_params->{'return_global'} = $self->{api_client}->to_query_value($args{'return_global'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    # query params
    if ( exists $args{'use_latest_api_version'}) {
        $query_params->{'use_latest_api_version'} = $self->{api_client}->to_query_value($args{'use_latest_api_version'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductChildItemList', $response);
    return $_response_object;
}

#
# product_count
#
# product.count
#
# @param string $product_ids Counts products specified by product ids (optional)
# @param string $since_id Retrieve entities starting from the specified id. (optional)
# @param string $categories_ids Defines product add that is specified by comma-separated categories id (optional)
# @param string $category_id Counts products specified by category id (optional)
# @param string $store_id Counts products specified by store id (optional)
# @param string $lang_id Counts products specified by language id (optional)
# @param boolean $avail_view Specifies the set of visible/invisible products (optional)
# @param boolean $avail_sale Specifies the set of available/not available products for sale (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param string $brand_name Retrieves brands specified by brand name (optional)
# @param ARRAY[string] $product_attributes Defines product attributes (optional)
# @param string $status Defines product&#39;s status (optional)
# @param string $type Defines products&#39;s type (optional)
# @param string $visible Filter items by visibility status (optional, default to 'everywhere')
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $find_where Counts products that are searched specified by field (optional)
# @param string $report_request_id Report request id (optional)
# @param boolean $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
# @param boolean $use_latest_api_version Use the latest platform API version (optional, default to false)
{
    my $params = {
    'product_ids' => {
        data_type => 'string',
        description => 'Counts products specified by product ids',
        required => '0',
    },
    'since_id' => {
        data_type => 'string',
        description => 'Retrieve entities starting from the specified id.',
        required => '0',
    },
    'categories_ids' => {
        data_type => 'string',
        description => 'Defines product add that is specified by comma-separated categories id',
        required => '0',
    },
    'category_id' => {
        data_type => 'string',
        description => 'Counts products specified by category id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Counts products specified by store id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Counts products specified by language id',
        required => '0',
    },
    'avail_view' => {
        data_type => 'boolean',
        description => 'Specifies the set of visible/invisible products',
        required => '0',
    },
    'avail_sale' => {
        data_type => 'boolean',
        description => 'Specifies the set of available/not available products for sale',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'brand_name' => {
        data_type => 'string',
        description => 'Retrieves brands specified by brand name',
        required => '0',
    },
    'product_attributes' => {
        data_type => 'ARRAY[string]',
        description => 'Defines product attributes',
        required => '0',
    },
    'status' => {
        data_type => 'string',
        description => 'Defines product&#39;s status',
        required => '0',
    },
    'type' => {
        data_type => 'string',
        description => 'Defines products&#39;s type',
        required => '0',
    },
    'visible' => {
        data_type => 'string',
        description => 'Filter items by visibility status',
        required => '0',
    },
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Counts products that are searched specified by field',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'return_global' => {
        data_type => 'boolean',
        description => 'Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned.',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    'use_latest_api_version' => {
        data_type => 'boolean',
        description => 'Use the latest platform API version',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_count' } = {
        summary => 'product.count',
        params => $params,
        returns => 'ProductCount200Response',
        };
}
# @return ProductCount200Response
#
sub product_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.count.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_ids'}) {
        $query_params->{'product_ids'} = $self->{api_client}->to_query_value($args{'product_ids'});
    }

    # query params
    if ( exists $args{'since_id'}) {
        $query_params->{'since_id'} = $self->{api_client}->to_query_value($args{'since_id'});
    }

    # query params
    if ( exists $args{'categories_ids'}) {
        $query_params->{'categories_ids'} = $self->{api_client}->to_query_value($args{'categories_ids'});
    }

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'avail_view'}) {
        $query_params->{'avail_view'} = $self->{api_client}->to_query_value($args{'avail_view'});
    }

    # query params
    if ( exists $args{'avail_sale'}) {
        $query_params->{'avail_sale'} = $self->{api_client}->to_query_value($args{'avail_sale'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'brand_name'}) {
        $query_params->{'brand_name'} = $self->{api_client}->to_query_value($args{'brand_name'});
    }

    # query params
    if ( exists $args{'product_attributes'}) {
        $query_params->{'product_attributes'} = $self->{api_client}->to_query_value($args{'product_attributes'});
    }

    # query params
    if ( exists $args{'status'}) {
        $query_params->{'status'} = $self->{api_client}->to_query_value($args{'status'});
    }

    # query params
    if ( exists $args{'type'}) {
        $query_params->{'type'} = $self->{api_client}->to_query_value($args{'type'});
    }

    # query params
    if ( exists $args{'visible'}) {
        $query_params->{'visible'} = $self->{api_client}->to_query_value($args{'visible'});
    }

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'return_global'}) {
        $query_params->{'return_global'} = $self->{api_client}->to_query_value($args{'return_global'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    # query params
    if ( exists $args{'use_latest_api_version'}) {
        $query_params->{'use_latest_api_version'} = $self->{api_client}->to_query_value($args{'use_latest_api_version'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductCount200Response', $response);
    return $_response_object;
}

#
# product_currency_add
#
# product.currency.add
#
# @param string $iso3 Specifies standardized currency code (required)
# @param double $rate Defines the numerical identifier against to the major currency (required)
# @param string $name Defines currency&#39;s name (optional)
# @param boolean $avail Specifies whether the currency is available (optional, default to true)
# @param string $symbol_left Defines the symbol that is located before the currency (optional)
# @param string $symbol_right Defines the symbol that is located after the currency (optional)
# @param boolean $default Specifies currency&#39;s default meaning (optional, default to false)
{
    my $params = {
    'iso3' => {
        data_type => 'string',
        description => 'Specifies standardized currency code',
        required => '1',
    },
    'rate' => {
        data_type => 'double',
        description => 'Defines the numerical identifier against to the major currency',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'Defines currency&#39;s name',
        required => '0',
    },
    'avail' => {
        data_type => 'boolean',
        description => 'Specifies whether the currency is available',
        required => '0',
    },
    'symbol_left' => {
        data_type => 'string',
        description => 'Defines the symbol that is located before the currency',
        required => '0',
    },
    'symbol_right' => {
        data_type => 'string',
        description => 'Defines the symbol that is located after the currency',
        required => '0',
    },
    'default' => {
        data_type => 'boolean',
        description => 'Specifies currency&#39;s default meaning',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_currency_add' } = {
        summary => 'product.currency.add',
        params => $params,
        returns => 'ProductCurrencyAdd200Response',
        };
}
# @return ProductCurrencyAdd200Response
#
sub product_currency_add {
    my ($self, %args) = @_;

    # verify the required parameter 'iso3' is set
    unless (exists $args{'iso3'}) {
      croak("Missing the required parameter 'iso3' when calling product_currency_add");
    }

    # verify the required parameter 'rate' is set
    unless (exists $args{'rate'}) {
      croak("Missing the required parameter 'rate' when calling product_currency_add");
    }

    # parse inputs
    my $_resource_path = '/product.currency.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'iso3'}) {
        $query_params->{'iso3'} = $self->{api_client}->to_query_value($args{'iso3'});
    }

    # query params
    if ( exists $args{'rate'}) {
        $query_params->{'rate'} = $self->{api_client}->to_query_value($args{'rate'});
    }

    # query params
    if ( exists $args{'name'}) {
        $query_params->{'name'} = $self->{api_client}->to_query_value($args{'name'});
    }

    # query params
    if ( exists $args{'avail'}) {
        $query_params->{'avail'} = $self->{api_client}->to_query_value($args{'avail'});
    }

    # query params
    if ( exists $args{'symbol_left'}) {
        $query_params->{'symbol_left'} = $self->{api_client}->to_query_value($args{'symbol_left'});
    }

    # query params
    if ( exists $args{'symbol_right'}) {
        $query_params->{'symbol_right'} = $self->{api_client}->to_query_value($args{'symbol_right'});
    }

    # query params
    if ( exists $args{'default'}) {
        $query_params->{'default'} = $self->{api_client}->to_query_value($args{'default'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductCurrencyAdd200Response', $response);
    return $_response_object;
}

#
# product_currency_list
#
# product.currency.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param boolean $default Specifies the set of default/not default currencies (optional)
# @param boolean $avail Specifies the set of available/not available currencies (optional)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'name,iso3,default,avail')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'default' => {
        data_type => 'boolean',
        description => 'Specifies the set of default/not default currencies',
        required => '0',
    },
    'avail' => {
        data_type => 'boolean',
        description => 'Specifies the set of available/not available currencies',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_currency_list' } = {
        summary => 'product.currency.list',
        params => $params,
        returns => 'ModelResponseProductCurrencyList',
        };
}
# @return ModelResponseProductCurrencyList
#
sub product_currency_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.currency.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'default'}) {
        $query_params->{'default'} = $self->{api_client}->to_query_value($args{'default'});
    }

    # query params
    if ( exists $args{'avail'}) {
        $query_params->{'avail'} = $self->{api_client}->to_query_value($args{'avail'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductCurrencyList', $response);
    return $_response_object;
}

#
# product_delete
#
# product.delete
#
# @param string $id Product id that will be removed (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Product id that will be removed',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_delete' } = {
        summary => 'product.delete',
        params => $params,
        returns => 'CustomerDelete200Response',
        };
}
# @return CustomerDelete200Response
#
sub product_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_delete");
    }

    # parse inputs
    my $_resource_path = '/product.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CustomerDelete200Response', $response);
    return $_response_object;
}

#
# product_delete_batch
#
# product.delete.batch
#
# @param ProductDeleteBatch $product_delete_batch  (required)
{
    my $params = {
    'product_delete_batch' => {
        data_type => 'ProductDeleteBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_delete_batch' } = {
        summary => 'product.delete.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub product_delete_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'product_delete_batch' is set
    unless (exists $args{'product_delete_batch'}) {
      croak("Missing the required parameter 'product_delete_batch' when calling product_delete_batch");
    }

    # parse inputs
    my $_resource_path = '/product.delete.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_delete_batch'}) {
        $_body_data = $args{'product_delete_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

#
# product_fields
#
# product.fields
#
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'product_fields' } = {
        summary => 'product.fields',
        params => $params,
        returns => 'CartConfigUpdate200Response',
        };
}
# @return CartConfigUpdate200Response
#
sub product_fields {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.fields.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CartConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_find
#
# product.find
#
# @param string $find_value Entity search that is specified by some value (required)
# @param string $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
# @param string $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
# @param string $find_what Parameter&#39;s value specifies the entity that has to be found (optional, default to 'product')
# @param string $lang_id Search products specified by language id (optional)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '1',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Entity search that is specified by the comma-separated unique fields',
        required => '0',
    },
    'find_params' => {
        data_type => 'string',
        description => 'Entity search that is specified by comma-separated parameters',
        required => '0',
    },
    'find_what' => {
        data_type => 'string',
        description => 'Parameter&#39;s value specifies the entity that has to be found',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Search products specified by language id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_find' } = {
        summary => 'product.find',
        params => $params,
        returns => 'ProductFind200Response',
        };
}
# @return ProductFind200Response
#
sub product_find {
    my ($self, %args) = @_;

    # verify the required parameter 'find_value' is set
    unless (exists $args{'find_value'}) {
      croak("Missing the required parameter 'find_value' when calling product_find");
    }

    # parse inputs
    my $_resource_path = '/product.find.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'find_params'}) {
        $query_params->{'find_params'} = $self->{api_client}->to_query_value($args{'find_params'});
    }

    # query params
    if ( exists $args{'find_what'}) {
        $query_params->{'find_what'} = $self->{api_client}->to_query_value($args{'find_what'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductFind200Response', $response);
    return $_response_object;
}

#
# product_image_add
#
# product.image.add
#
# @param ProductImageAdd $product_image_add  (required)
{
    my $params = {
    'product_image_add' => {
        data_type => 'ProductImageAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_image_add' } = {
        summary => 'product.image.add',
        params => $params,
        returns => 'ProductImageAdd200Response',
        };
}
# @return ProductImageAdd200Response
#
sub product_image_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_image_add' is set
    unless (exists $args{'product_image_add'}) {
      croak("Missing the required parameter 'product_image_add' when calling product_image_add");
    }

    # parse inputs
    my $_resource_path = '/product.image.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_image_add'}) {
        $_body_data = $args{'product_image_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductImageAdd200Response', $response);
    return $_response_object;
}

#
# product_image_delete
#
# product.image.delete
#
# @param string $product_id Defines product id where the image should be deleted (required)
# @param string $id Entity id (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the image should be deleted',
        required => '1',
    },
    'id' => {
        data_type => 'string',
        description => 'Entity id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_image_delete' } = {
        summary => 'product.image.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub product_image_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_image_delete");
    }

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_image_delete");
    }

    # parse inputs
    my $_resource_path = '/product.image.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# product_image_update
#
# product.image.update
#
# @param string $product_id Defines product id where the image should be updated (required)
# @param string $id Defines image update specified by image id (required)
# @param string $variant_ids Defines product&#39;s variants ids (optional)
# @param string $store_id Store Id (optional)
# @param string $lang_id Language id (optional)
# @param string $image_name Defines image&#39;s name (optional)
# @param string $type Defines image&#39;s types that are specified by comma-separated list (optional, default to 'additional')
# @param string $label Defines alternative text that has to be attached to the picture (optional)
# @param int $position Defines images position in the list (optional)
# @param boolean $hidden Define is hide image (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the image should be updated',
        required => '1',
    },
    'id' => {
        data_type => 'string',
        description => 'Defines image update specified by image id',
        required => '1',
    },
    'variant_ids' => {
        data_type => 'string',
        description => 'Defines product&#39;s variants ids',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'image_name' => {
        data_type => 'string',
        description => 'Defines image&#39;s name',
        required => '0',
    },
    'type' => {
        data_type => 'string',
        description => 'Defines image&#39;s types that are specified by comma-separated list',
        required => '0',
    },
    'label' => {
        data_type => 'string',
        description => 'Defines alternative text that has to be attached to the picture',
        required => '0',
    },
    'position' => {
        data_type => 'int',
        description => 'Defines images position in the list',
        required => '0',
    },
    'hidden' => {
        data_type => 'boolean',
        description => 'Define is hide image',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_image_update' } = {
        summary => 'product.image.update',
        params => $params,
        returns => 'ProductImageUpdate200Response',
        };
}
# @return ProductImageUpdate200Response
#
sub product_image_update {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_image_update");
    }

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_image_update");
    }

    # parse inputs
    my $_resource_path = '/product.image.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'variant_ids'}) {
        $query_params->{'variant_ids'} = $self->{api_client}->to_query_value($args{'variant_ids'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'image_name'}) {
        $query_params->{'image_name'} = $self->{api_client}->to_query_value($args{'image_name'});
    }

    # query params
    if ( exists $args{'type'}) {
        $query_params->{'type'} = $self->{api_client}->to_query_value($args{'type'});
    }

    # query params
    if ( exists $args{'label'}) {
        $query_params->{'label'} = $self->{api_client}->to_query_value($args{'label'});
    }

    # query params
    if ( exists $args{'position'}) {
        $query_params->{'position'} = $self->{api_client}->to_query_value($args{'position'});
    }

    # query params
    if ( exists $args{'hidden'}) {
        $query_params->{'hidden'} = $self->{api_client}->to_query_value($args{'hidden'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductImageUpdate200Response', $response);
    return $_response_object;
}

#
# product_info
#
# product.info
#
# @param string $id Retrieves product&#39;s info specified by product id (required)
# @param string $store_id Retrieves product info specified by store id (optional)
# @param string $lang_id Retrieves product info specified by language id (optional)
# @param string $currency_id Currency Id (optional)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
# @param string $report_request_id Report request id (optional)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
# @param boolean $use_latest_api_version Use the latest platform API version (optional, default to false)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Retrieves product&#39;s info specified by product id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves product info specified by store id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Retrieves product info specified by language id',
        required => '0',
    },
    'currency_id' => {
        data_type => 'string',
        description => 'Currency Id',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    'use_latest_api_version' => {
        data_type => 'boolean',
        description => 'Use the latest platform API version',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_info' } = {
        summary => 'product.info',
        params => $params,
        returns => 'ProductInfo200Response',
        };
}
# @return ProductInfo200Response
#
sub product_info {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_info");
    }

    # parse inputs
    my $_resource_path = '/product.info.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'currency_id'}) {
        $query_params->{'currency_id'} = $self->{api_client}->to_query_value($args{'currency_id'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    # query params
    if ( exists $args{'use_latest_api_version'}) {
        $query_params->{'use_latest_api_version'} = $self->{api_client}->to_query_value($args{'use_latest_api_version'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductInfo200Response', $response);
    return $_response_object;
}

#
# product_list
#
# product.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param string $product_ids Retrieves products specified by product ids (optional)
# @param string $since_id Retrieve entities starting from the specified id. (optional)
# @param string $categories_ids Retrieves products specified by categories ids (optional)
# @param string $category_id Retrieves products specified by category id (optional)
# @param string $store_id Retrieves products specified by store id (optional)
# @param string $lang_id Retrieves products specified by language id (optional)
# @param string $currency_id Currency Id (optional)
# @param boolean $avail_view Specifies the set of visible/invisible products (optional)
# @param boolean $avail_sale Specifies the set of available/not available products for sale (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param string $sku Filter by product&#39;s sku (optional)
# @param string $brand_name Retrieves brands specified by brand name (optional)
# @param ARRAY[string] $product_attributes Defines product attributes (optional)
# @param string $status Defines product&#39;s status (optional)
# @param string $type Defines products&#39;s type (optional)
# @param string $visible Filter items by visibility status (optional, default to 'everywhere')
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $find_where Product search that is specified by field (optional)
# @param boolean $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
# @param string $sort_by Set field to sort by (optional, default to 'id')
# @param string $sort_direction Set sorting direction (optional, default to 'asc')
# @param string $report_request_id Report request id (optional)
# @param boolean $disable_cache Disable cache for current request (optional, default to false)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
# @param boolean $use_latest_api_version Use the latest platform API version (optional, default to false)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'product_ids' => {
        data_type => 'string',
        description => 'Retrieves products specified by product ids',
        required => '0',
    },
    'since_id' => {
        data_type => 'string',
        description => 'Retrieve entities starting from the specified id.',
        required => '0',
    },
    'categories_ids' => {
        data_type => 'string',
        description => 'Retrieves products specified by categories ids',
        required => '0',
    },
    'category_id' => {
        data_type => 'string',
        description => 'Retrieves products specified by category id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves products specified by store id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Retrieves products specified by language id',
        required => '0',
    },
    'currency_id' => {
        data_type => 'string',
        description => 'Currency Id',
        required => '0',
    },
    'avail_view' => {
        data_type => 'boolean',
        description => 'Specifies the set of visible/invisible products',
        required => '0',
    },
    'avail_sale' => {
        data_type => 'boolean',
        description => 'Specifies the set of available/not available products for sale',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'sku' => {
        data_type => 'string',
        description => 'Filter by product&#39;s sku',
        required => '0',
    },
    'brand_name' => {
        data_type => 'string',
        description => 'Retrieves brands specified by brand name',
        required => '0',
    },
    'product_attributes' => {
        data_type => 'ARRAY[string]',
        description => 'Defines product attributes',
        required => '0',
    },
    'status' => {
        data_type => 'string',
        description => 'Defines product&#39;s status',
        required => '0',
    },
    'type' => {
        data_type => 'string',
        description => 'Defines products&#39;s type',
        required => '0',
    },
    'visible' => {
        data_type => 'string',
        description => 'Filter items by visibility status',
        required => '0',
    },
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Product search that is specified by field',
        required => '0',
    },
    'return_global' => {
        data_type => 'boolean',
        description => 'Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned.',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    'sort_by' => {
        data_type => 'string',
        description => 'Set field to sort by',
        required => '0',
    },
    'sort_direction' => {
        data_type => 'string',
        description => 'Set sorting direction',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'disable_cache' => {
        data_type => 'boolean',
        description => 'Disable cache for current request',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    'use_latest_api_version' => {
        data_type => 'boolean',
        description => 'Use the latest platform API version',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_list' } = {
        summary => 'product.list',
        params => $params,
        returns => 'ModelResponseProductList',
        };
}
# @return ModelResponseProductList
#
sub product_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'product_ids'}) {
        $query_params->{'product_ids'} = $self->{api_client}->to_query_value($args{'product_ids'});
    }

    # query params
    if ( exists $args{'since_id'}) {
        $query_params->{'since_id'} = $self->{api_client}->to_query_value($args{'since_id'});
    }

    # query params
    if ( exists $args{'categories_ids'}) {
        $query_params->{'categories_ids'} = $self->{api_client}->to_query_value($args{'categories_ids'});
    }

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'currency_id'}) {
        $query_params->{'currency_id'} = $self->{api_client}->to_query_value($args{'currency_id'});
    }

    # query params
    if ( exists $args{'avail_view'}) {
        $query_params->{'avail_view'} = $self->{api_client}->to_query_value($args{'avail_view'});
    }

    # query params
    if ( exists $args{'avail_sale'}) {
        $query_params->{'avail_sale'} = $self->{api_client}->to_query_value($args{'avail_sale'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'sku'}) {
        $query_params->{'sku'} = $self->{api_client}->to_query_value($args{'sku'});
    }

    # query params
    if ( exists $args{'brand_name'}) {
        $query_params->{'brand_name'} = $self->{api_client}->to_query_value($args{'brand_name'});
    }

    # query params
    if ( exists $args{'product_attributes'}) {
        $query_params->{'product_attributes'} = $self->{api_client}->to_query_value($args{'product_attributes'});
    }

    # query params
    if ( exists $args{'status'}) {
        $query_params->{'status'} = $self->{api_client}->to_query_value($args{'status'});
    }

    # query params
    if ( exists $args{'type'}) {
        $query_params->{'type'} = $self->{api_client}->to_query_value($args{'type'});
    }

    # query params
    if ( exists $args{'visible'}) {
        $query_params->{'visible'} = $self->{api_client}->to_query_value($args{'visible'});
    }

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'return_global'}) {
        $query_params->{'return_global'} = $self->{api_client}->to_query_value($args{'return_global'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    # query params
    if ( exists $args{'sort_by'}) {
        $query_params->{'sort_by'} = $self->{api_client}->to_query_value($args{'sort_by'});
    }

    # query params
    if ( exists $args{'sort_direction'}) {
        $query_params->{'sort_direction'} = $self->{api_client}->to_query_value($args{'sort_direction'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'disable_cache'}) {
        $query_params->{'disable_cache'} = $self->{api_client}->to_query_value($args{'disable_cache'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    # query params
    if ( exists $args{'use_latest_api_version'}) {
        $query_params->{'use_latest_api_version'} = $self->{api_client}->to_query_value($args{'use_latest_api_version'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductList', $response);
    return $_response_object;
}

#
# product_manufacturer_add
#
# product.manufacturer.add
#
# @param string $product_id Defines products specified by product id (required)
# @param string $manufacturer Defines products manufacturer&#39;s name (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines products specified by product id',
        required => '1',
    },
    'manufacturer' => {
        data_type => 'string',
        description => 'Defines products manufacturer&#39;s name',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_manufacturer_add' } = {
        summary => 'product.manufacturer.add',
        params => $params,
        returns => 'ProductManufacturerAdd200Response',
        };
}
# @return ProductManufacturerAdd200Response
#
sub product_manufacturer_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_manufacturer_add");
    }

    # verify the required parameter 'manufacturer' is set
    unless (exists $args{'manufacturer'}) {
      croak("Missing the required parameter 'manufacturer' when calling product_manufacturer_add");
    }

    # parse inputs
    my $_resource_path = '/product.manufacturer.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'manufacturer'}) {
        $query_params->{'manufacturer'} = $self->{api_client}->to_query_value($args{'manufacturer'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductManufacturerAdd200Response', $response);
    return $_response_object;
}

#
# product_option_add
#
# product.option.add
#
# @param ProductOptionAdd $product_option_add  (required)
{
    my $params = {
    'product_option_add' => {
        data_type => 'ProductOptionAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_add' } = {
        summary => 'product.option.add',
        params => $params,
        returns => 'ProductOptionAdd200Response',
        };
}
# @return ProductOptionAdd200Response
#
sub product_option_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_option_add' is set
    unless (exists $args{'product_option_add'}) {
      croak("Missing the required parameter 'product_option_add' when calling product_option_add");
    }

    # parse inputs
    my $_resource_path = '/product.option.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_option_add'}) {
        $_body_data = $args{'product_option_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductOptionAdd200Response', $response);
    return $_response_object;
}

#
# product_option_assign
#
# product.option.assign
#
# @param string $product_id Defines product id where the option should be assigned (required)
# @param string $option_id Defines option id which has to be assigned (required)
# @param boolean $required Defines if the option is required (optional, default to false)
# @param int $sort_order Sort number in the list (optional, default to 0)
# @param string $option_values Defines option values that has to be assigned (optional)
# @param boolean $clear_cache Is cache clear required (optional, default to true)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the option should be assigned',
        required => '1',
    },
    'option_id' => {
        data_type => 'string',
        description => 'Defines option id which has to be assigned',
        required => '1',
    },
    'required' => {
        data_type => 'boolean',
        description => 'Defines if the option is required',
        required => '0',
    },
    'sort_order' => {
        data_type => 'int',
        description => 'Sort number in the list',
        required => '0',
    },
    'option_values' => {
        data_type => 'string',
        description => 'Defines option values that has to be assigned',
        required => '0',
    },
    'clear_cache' => {
        data_type => 'boolean',
        description => 'Is cache clear required',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_assign' } = {
        summary => 'product.option.assign',
        params => $params,
        returns => 'ProductOptionAssign200Response',
        };
}
# @return ProductOptionAssign200Response
#
sub product_option_assign {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_option_assign");
    }

    # verify the required parameter 'option_id' is set
    unless (exists $args{'option_id'}) {
      croak("Missing the required parameter 'option_id' when calling product_option_assign");
    }

    # parse inputs
    my $_resource_path = '/product.option.assign.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'option_id'}) {
        $query_params->{'option_id'} = $self->{api_client}->to_query_value($args{'option_id'});
    }

    # query params
    if ( exists $args{'required'}) {
        $query_params->{'required'} = $self->{api_client}->to_query_value($args{'required'});
    }

    # query params
    if ( exists $args{'sort_order'}) {
        $query_params->{'sort_order'} = $self->{api_client}->to_query_value($args{'sort_order'});
    }

    # query params
    if ( exists $args{'option_values'}) {
        $query_params->{'option_values'} = $self->{api_client}->to_query_value($args{'option_values'});
    }

    # query params
    if ( exists $args{'clear_cache'}) {
        $query_params->{'clear_cache'} = $self->{api_client}->to_query_value($args{'clear_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductOptionAssign200Response', $response);
    return $_response_object;
}

#
# product_option_delete
#
# product.option.delete
#
# @param string $option_id Defines option id that should be deleted (required)
# @param string $product_id Defines product id where the option should be deleted (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'option_id' => {
        data_type => 'string',
        description => 'Defines option id that should be deleted',
        required => '1',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the option should be deleted',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_delete' } = {
        summary => 'product.option.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub product_option_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'option_id' is set
    unless (exists $args{'option_id'}) {
      croak("Missing the required parameter 'option_id' when calling product_option_delete");
    }

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_option_delete");
    }

    # parse inputs
    my $_resource_path = '/product.option.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'option_id'}) {
        $query_params->{'option_id'} = $self->{api_client}->to_query_value($args{'option_id'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# product_option_list
#
# product.option.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $product_id Retrieves products&#39; options specified by product id (optional)
# @param string $lang_id Language id (optional)
# @param string $store_id Store Id (optional)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Retrieves products&#39; options specified by product id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_list' } = {
        summary => 'product.option.list',
        params => $params,
        returns => 'ModelResponseProductOptionList',
        };
}
# @return ModelResponseProductOptionList
#
sub product_option_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.option.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductOptionList', $response);
    return $_response_object;
}

#
# product_option_value_add
#
# product.option.value.add
#
# @param string $product_id Defines product id where the option value should be added (required)
# @param string $option_id Defines option id where the value has to be added (required)
# @param string $option_value Defines option value that has to be added (optional)
# @param int $sort_order Sort number in the list (optional, default to 0)
# @param string $display_value Defines the value that will be displayed for the option value (optional)
# @param boolean $is_default Defines as a default (optional)
# @param boolean $clear_cache Is cache clear required (optional, default to true)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the option value should be added',
        required => '1',
    },
    'option_id' => {
        data_type => 'string',
        description => 'Defines option id where the value has to be added',
        required => '1',
    },
    'option_value' => {
        data_type => 'string',
        description => 'Defines option value that has to be added',
        required => '0',
    },
    'sort_order' => {
        data_type => 'int',
        description => 'Sort number in the list',
        required => '0',
    },
    'display_value' => {
        data_type => 'string',
        description => 'Defines the value that will be displayed for the option value',
        required => '0',
    },
    'is_default' => {
        data_type => 'boolean',
        description => 'Defines as a default',
        required => '0',
    },
    'clear_cache' => {
        data_type => 'boolean',
        description => 'Is cache clear required',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_value_add' } = {
        summary => 'product.option.value.add',
        params => $params,
        returns => 'ProductOptionValueAdd200Response',
        };
}
# @return ProductOptionValueAdd200Response
#
sub product_option_value_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_option_value_add");
    }

    # verify the required parameter 'option_id' is set
    unless (exists $args{'option_id'}) {
      croak("Missing the required parameter 'option_id' when calling product_option_value_add");
    }

    # parse inputs
    my $_resource_path = '/product.option.value.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'option_id'}) {
        $query_params->{'option_id'} = $self->{api_client}->to_query_value($args{'option_id'});
    }

    # query params
    if ( exists $args{'option_value'}) {
        $query_params->{'option_value'} = $self->{api_client}->to_query_value($args{'option_value'});
    }

    # query params
    if ( exists $args{'sort_order'}) {
        $query_params->{'sort_order'} = $self->{api_client}->to_query_value($args{'sort_order'});
    }

    # query params
    if ( exists $args{'display_value'}) {
        $query_params->{'display_value'} = $self->{api_client}->to_query_value($args{'display_value'});
    }

    # query params
    if ( exists $args{'is_default'}) {
        $query_params->{'is_default'} = $self->{api_client}->to_query_value($args{'is_default'});
    }

    # query params
    if ( exists $args{'clear_cache'}) {
        $query_params->{'clear_cache'} = $self->{api_client}->to_query_value($args{'clear_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductOptionValueAdd200Response', $response);
    return $_response_object;
}

#
# product_option_value_assign
#
# product.option.value.assign
#
# @param int $product_option_id Defines product&#39;s option id where the value has to be assigned (required)
# @param string $option_value_id Defines value id that has to be assigned (required)
# @param boolean $clear_cache Is cache clear required (optional, default to true)
{
    my $params = {
    'product_option_id' => {
        data_type => 'int',
        description => 'Defines product&#39;s option id where the value has to be assigned',
        required => '1',
    },
    'option_value_id' => {
        data_type => 'string',
        description => 'Defines value id that has to be assigned',
        required => '1',
    },
    'clear_cache' => {
        data_type => 'boolean',
        description => 'Is cache clear required',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_value_assign' } = {
        summary => 'product.option.value.assign',
        params => $params,
        returns => 'ProductOptionValueAssign200Response',
        };
}
# @return ProductOptionValueAssign200Response
#
sub product_option_value_assign {
    my ($self, %args) = @_;

    # verify the required parameter 'product_option_id' is set
    unless (exists $args{'product_option_id'}) {
      croak("Missing the required parameter 'product_option_id' when calling product_option_value_assign");
    }

    # verify the required parameter 'option_value_id' is set
    unless (exists $args{'option_value_id'}) {
      croak("Missing the required parameter 'option_value_id' when calling product_option_value_assign");
    }

    # parse inputs
    my $_resource_path = '/product.option.value.assign.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_option_id'}) {
        $query_params->{'product_option_id'} = $self->{api_client}->to_query_value($args{'product_option_id'});
    }

    # query params
    if ( exists $args{'option_value_id'}) {
        $query_params->{'option_value_id'} = $self->{api_client}->to_query_value($args{'option_value_id'});
    }

    # query params
    if ( exists $args{'clear_cache'}) {
        $query_params->{'clear_cache'} = $self->{api_client}->to_query_value($args{'clear_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductOptionValueAssign200Response', $response);
    return $_response_object;
}

#
# product_option_value_delete
#
# product.option.value.delete
#
# @param string $option_id Defines option id where the value should be deleted (required)
# @param string $option_value_id Defines option value id that should be deleted (required)
# @param string $product_id Defines product id where the option value should be deleted (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'option_id' => {
        data_type => 'string',
        description => 'Defines option id where the value should be deleted',
        required => '1',
    },
    'option_value_id' => {
        data_type => 'string',
        description => 'Defines option value id that should be deleted',
        required => '1',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the option value should be deleted',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_value_delete' } = {
        summary => 'product.option.value.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub product_option_value_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'option_id' is set
    unless (exists $args{'option_id'}) {
      croak("Missing the required parameter 'option_id' when calling product_option_value_delete");
    }

    # verify the required parameter 'option_value_id' is set
    unless (exists $args{'option_value_id'}) {
      croak("Missing the required parameter 'option_value_id' when calling product_option_value_delete");
    }

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_option_value_delete");
    }

    # parse inputs
    my $_resource_path = '/product.option.value.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'option_id'}) {
        $query_params->{'option_id'} = $self->{api_client}->to_query_value($args{'option_id'});
    }

    # query params
    if ( exists $args{'option_value_id'}) {
        $query_params->{'option_value_id'} = $self->{api_client}->to_query_value($args{'option_value_id'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# product_option_value_update
#
# product.option.value.update
#
# @param string $product_id Defines product id where the option value should be updated (required)
# @param string $option_id Defines option id where the value has to be updated (required)
# @param string $option_value_id Defines value id that has to be assigned (required)
# @param string $option_value Defines option value that has to be added (optional)
# @param double $price Defines new product option price (optional)
# @param double $quantity Defines new products&#39; options quantity (optional)
# @param string $display_value Defines the value that will be displayed for the option value (optional)
# @param boolean $clear_cache Is cache clear required (optional, default to true)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the option value should be updated',
        required => '1',
    },
    'option_id' => {
        data_type => 'string',
        description => 'Defines option id where the value has to be updated',
        required => '1',
    },
    'option_value_id' => {
        data_type => 'string',
        description => 'Defines value id that has to be assigned',
        required => '1',
    },
    'option_value' => {
        data_type => 'string',
        description => 'Defines option value that has to be added',
        required => '0',
    },
    'price' => {
        data_type => 'double',
        description => 'Defines new product option price',
        required => '0',
    },
    'quantity' => {
        data_type => 'double',
        description => 'Defines new products&#39; options quantity',
        required => '0',
    },
    'display_value' => {
        data_type => 'string',
        description => 'Defines the value that will be displayed for the option value',
        required => '0',
    },
    'clear_cache' => {
        data_type => 'boolean',
        description => 'Is cache clear required',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_option_value_update' } = {
        summary => 'product.option.value.update',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub product_option_value_update {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_option_value_update");
    }

    # verify the required parameter 'option_id' is set
    unless (exists $args{'option_id'}) {
      croak("Missing the required parameter 'option_id' when calling product_option_value_update");
    }

    # verify the required parameter 'option_value_id' is set
    unless (exists $args{'option_value_id'}) {
      croak("Missing the required parameter 'option_value_id' when calling product_option_value_update");
    }

    # parse inputs
    my $_resource_path = '/product.option.value.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'option_id'}) {
        $query_params->{'option_id'} = $self->{api_client}->to_query_value($args{'option_id'});
    }

    # query params
    if ( exists $args{'option_value_id'}) {
        $query_params->{'option_value_id'} = $self->{api_client}->to_query_value($args{'option_value_id'});
    }

    # query params
    if ( exists $args{'option_value'}) {
        $query_params->{'option_value'} = $self->{api_client}->to_query_value($args{'option_value'});
    }

    # query params
    if ( exists $args{'price'}) {
        $query_params->{'price'} = $self->{api_client}->to_query_value($args{'price'});
    }

    # query params
    if ( exists $args{'quantity'}) {
        $query_params->{'quantity'} = $self->{api_client}->to_query_value($args{'quantity'});
    }

    # query params
    if ( exists $args{'display_value'}) {
        $query_params->{'display_value'} = $self->{api_client}->to_query_value($args{'display_value'});
    }

    # query params
    if ( exists $args{'clear_cache'}) {
        $query_params->{'clear_cache'} = $self->{api_client}->to_query_value($args{'clear_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_price_add
#
# product.price.add
#
# @param ProductPriceAdd $product_price_add  (required)
{
    my $params = {
    'product_price_add' => {
        data_type => 'ProductPriceAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_price_add' } = {
        summary => 'product.price.add',
        params => $params,
        returns => 'CartValidate200Response',
        };
}
# @return CartValidate200Response
#
sub product_price_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_price_add' is set
    unless (exists $args{'product_price_add'}) {
      croak("Missing the required parameter 'product_price_add' when calling product_price_add");
    }

    # parse inputs
    my $_resource_path = '/product.price.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_price_add'}) {
        $_body_data = $args{'product_price_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CartValidate200Response', $response);
    return $_response_object;
}

#
# product_price_delete
#
# product.price.delete
#
# @param string $product_id Defines the product where the price has to be deleted (required)
# @param string $group_prices Defines product&#39;s group prices (optional)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines the product where the price has to be deleted',
        required => '1',
    },
    'group_prices' => {
        data_type => 'string',
        description => 'Defines product&#39;s group prices',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_price_delete' } = {
        summary => 'product.price.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub product_price_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_price_delete");
    }

    # parse inputs
    my $_resource_path = '/product.price.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'group_prices'}) {
        $query_params->{'group_prices'} = $self->{api_client}->to_query_value($args{'group_prices'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# product_price_update
#
# product.price.update
#
# @param ProductPriceUpdate $product_price_update  (required)
{
    my $params = {
    'product_price_update' => {
        data_type => 'ProductPriceUpdate',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_price_update' } = {
        summary => 'product.price.update',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub product_price_update {
    my ($self, %args) = @_;

    # verify the required parameter 'product_price_update' is set
    unless (exists $args{'product_price_update'}) {
      croak("Missing the required parameter 'product_price_update' when calling product_price_update");
    }

    # parse inputs
    my $_resource_path = '/product.price.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_price_update'}) {
        $_body_data = $args{'product_price_update'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_review_list
#
# product.review.list
#
# @param string $product_id Product id (required)
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param string $ids Retrieves reviews specified by ids (optional)
# @param string $store_id Store Id (optional)
# @param string $status Defines status (optional)
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Product id',
        required => '1',
    },
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'ids' => {
        data_type => 'string',
        description => 'Retrieves reviews specified by ids',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'status' => {
        data_type => 'string',
        description => 'Defines status',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_review_list' } = {
        summary => 'product.review.list',
        params => $params,
        returns => 'ModelResponseProductReviewList',
        };
}
# @return ModelResponseProductReviewList
#
sub product_review_list {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_review_list");
    }

    # parse inputs
    my $_resource_path = '/product.review.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'ids'}) {
        $query_params->{'ids'} = $self->{api_client}->to_query_value($args{'ids'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'status'}) {
        $query_params->{'status'} = $self->{api_client}->to_query_value($args{'status'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseProductReviewList', $response);
    return $_response_object;
}

#
# product_store_assign
#
# product.store.assign
#
# @param string $product_id Defines id of the product which should be assigned to a store (required)
# @param string $store_id Defines id of the store product should be assigned to (required)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines id of the product which should be assigned to a store',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Defines id of the store product should be assigned to',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_store_assign' } = {
        summary => 'product.store.assign',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub product_store_assign {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_store_assign");
    }

    # verify the required parameter 'store_id' is set
    unless (exists $args{'store_id'}) {
      croak("Missing the required parameter 'store_id' when calling product_store_assign");
    }

    # parse inputs
    my $_resource_path = '/product.store.assign.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_tax_add
#
# product.tax.add
#
# @param ProductTaxAdd $product_tax_add  (required)
{
    my $params = {
    'product_tax_add' => {
        data_type => 'ProductTaxAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_tax_add' } = {
        summary => 'product.tax.add',
        params => $params,
        returns => 'ProductTaxAdd200Response',
        };
}
# @return ProductTaxAdd200Response
#
sub product_tax_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_tax_add' is set
    unless (exists $args{'product_tax_add'}) {
      croak("Missing the required parameter 'product_tax_add' when calling product_tax_add");
    }

    # parse inputs
    my $_resource_path = '/product.tax.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_tax_add'}) {
        $_body_data = $args{'product_tax_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductTaxAdd200Response', $response);
    return $_response_object;
}

#
# product_update
#
# product.update
#
# @param ProductUpdate $product_update  (required)
{
    my $params = {
    'product_update' => {
        data_type => 'ProductUpdate',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_update' } = {
        summary => 'product.update',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub product_update {
    my ($self, %args) = @_;

    # verify the required parameter 'product_update' is set
    unless (exists $args{'product_update'}) {
      croak("Missing the required parameter 'product_update' when calling product_update");
    }

    # parse inputs
    my $_resource_path = '/product.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_update'}) {
        $_body_data = $args{'product_update'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_update_batch
#
# product.update.batch
#
# @param ProductUpdateBatch $product_update_batch  (required)
{
    my $params = {
    'product_update_batch' => {
        data_type => 'ProductUpdateBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_update_batch' } = {
        summary => 'product.update.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub product_update_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'product_update_batch' is set
    unless (exists $args{'product_update_batch'}) {
      croak("Missing the required parameter 'product_update_batch' when calling product_update_batch");
    }

    # parse inputs
    my $_resource_path = '/product.update.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_update_batch'}) {
        $_body_data = $args{'product_update_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

#
# product_variant_add
#
# product.variant.add
#
# @param ProductVariantAdd $product_variant_add  (required)
{
    my $params = {
    'product_variant_add' => {
        data_type => 'ProductVariantAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_add' } = {
        summary => 'product.variant.add',
        params => $params,
        returns => 'ProductVariantAdd200Response',
        };
}
# @return ProductVariantAdd200Response
#
sub product_variant_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_add' is set
    unless (exists $args{'product_variant_add'}) {
      croak("Missing the required parameter 'product_variant_add' when calling product_variant_add");
    }

    # parse inputs
    my $_resource_path = '/product.variant.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_add'}) {
        $_body_data = $args{'product_variant_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductVariantAdd200Response', $response);
    return $_response_object;
}

#
# product_variant_add_batch
#
# product.variant.add.batch
#
# @param ProductVariantAddBatch $product_variant_add_batch  (required)
{
    my $params = {
    'product_variant_add_batch' => {
        data_type => 'ProductVariantAddBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_add_batch' } = {
        summary => 'product.variant.add.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub product_variant_add_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_add_batch' is set
    unless (exists $args{'product_variant_add_batch'}) {
      croak("Missing the required parameter 'product_variant_add_batch' when calling product_variant_add_batch");
    }

    # parse inputs
    my $_resource_path = '/product.variant.add.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_add_batch'}) {
        $_body_data = $args{'product_variant_add_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

#
# product_variant_count
#
# product.variant.count
#
# @param string $product_id Retrieves products&#39; variants specified by product id (required)
# @param string $category_id Counts products variants specified by category id (optional)
# @param string $store_id Retrieves variants specified by store id (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Retrieves products&#39; variants specified by product id',
        required => '1',
    },
    'category_id' => {
        data_type => 'string',
        description => 'Counts products variants specified by category id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves variants specified by store id',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_count' } = {
        summary => 'product.variant.count',
        params => $params,
        returns => 'ProductVariantCount200Response',
        };
}
# @return ProductVariantCount200Response
#
sub product_variant_count {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_variant_count");
    }

    # parse inputs
    my $_resource_path = '/product.variant.count.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductVariantCount200Response', $response);
    return $_response_object;
}

#
# product_variant_delete
#
# product.variant.delete
#
# @param string $id Defines variant removal, specified by variant id (required)
# @param string $product_id Defines product&#39;s id where the variant has to be deleted (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Defines variant removal, specified by variant id',
        required => '1',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Defines product&#39;s id where the variant has to be deleted',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_delete' } = {
        summary => 'product.variant.delete',
        params => $params,
        returns => 'AttributeValueDelete200Response',
        };
}
# @return AttributeValueDelete200Response
#
sub product_variant_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_variant_delete");
    }

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_variant_delete");
    }

    # parse inputs
    my $_resource_path = '/product.variant.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeValueDelete200Response', $response);
    return $_response_object;
}

#
# product_variant_delete_batch
#
# product.variant.delete.batch
#
# @param ProductVariantDeleteBatch $product_variant_delete_batch  (required)
{
    my $params = {
    'product_variant_delete_batch' => {
        data_type => 'ProductVariantDeleteBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_delete_batch' } = {
        summary => 'product.variant.delete.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub product_variant_delete_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_delete_batch' is set
    unless (exists $args{'product_variant_delete_batch'}) {
      croak("Missing the required parameter 'product_variant_delete_batch' when calling product_variant_delete_batch");
    }

    # parse inputs
    my $_resource_path = '/product.variant.delete.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_delete_batch'}) {
        $_body_data = $args{'product_variant_delete_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

#
# product_variant_image_add
#
# product.variant.image.add
#
# @param ProductVariantImageAdd $product_variant_image_add  (required)
{
    my $params = {
    'product_variant_image_add' => {
        data_type => 'ProductVariantImageAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_image_add' } = {
        summary => 'product.variant.image.add',
        params => $params,
        returns => 'ProductVariantImageAdd200Response',
        };
}
# @return ProductVariantImageAdd200Response
#
sub product_variant_image_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_image_add' is set
    unless (exists $args{'product_variant_image_add'}) {
      croak("Missing the required parameter 'product_variant_image_add' when calling product_variant_image_add");
    }

    # parse inputs
    my $_resource_path = '/product.variant.image.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_image_add'}) {
        $_body_data = $args{'product_variant_image_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductVariantImageAdd200Response', $response);
    return $_response_object;
}

#
# product_variant_image_delete
#
# product.variant.image.delete
#
# @param string $product_id Defines product id where the variant image should be deleted (required)
# @param string $product_variant_id Defines product&#39;s variants specified by variant id (required)
# @param string $id Entity id (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines product id where the variant image should be deleted',
        required => '1',
    },
    'product_variant_id' => {
        data_type => 'string',
        description => 'Defines product&#39;s variants specified by variant id',
        required => '1',
    },
    'id' => {
        data_type => 'string',
        description => 'Entity id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_image_delete' } = {
        summary => 'product.variant.image.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub product_variant_image_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_variant_image_delete");
    }

    # verify the required parameter 'product_variant_id' is set
    unless (exists $args{'product_variant_id'}) {
      croak("Missing the required parameter 'product_variant_id' when calling product_variant_image_delete");
    }

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_variant_image_delete");
    }

    # parse inputs
    my $_resource_path = '/product.variant.image.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'product_variant_id'}) {
        $query_params->{'product_variant_id'} = $self->{api_client}->to_query_value($args{'product_variant_id'});
    }

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# product_variant_info
#
# product.variant.info
#
# @param string $id Retrieves variant&#39;s info specified by variant id (required)
# @param string $store_id Retrieves variant info specified by store id (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Retrieves variant&#39;s info specified by variant id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves variant info specified by store id',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_info' } = {
        summary => 'product.variant.info',
        params => $params,
        returns => 'ProductInfo200Response',
        };
}
# @return ProductInfo200Response
#
sub product_variant_info {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_variant_info");
    }

    # parse inputs
    my $_resource_path = '/product.variant.info.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductInfo200Response', $response);
    return $_response_object;
}

#
# product_variant_list
#
# product.variant.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $product_id Retrieves products&#39; variants specified by product id (optional)
# @param string $category_id Retrieves products variants specified by category id (optional)
# @param string $store_id Retrieves variants specified by store id (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Retrieves products&#39; variants specified by product id',
        required => '0',
    },
    'category_id' => {
        data_type => 'string',
        description => 'Retrieves products variants specified by category id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves variants specified by store id',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_list' } = {
        summary => 'product.variant.list',
        params => $params,
        returns => 'ProductVariantList200Response',
        };
}
# @return ProductVariantList200Response
#
sub product_variant_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/product.variant.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ProductVariantList200Response', $response);
    return $_response_object;
}

#
# product_variant_price_add
#
# product.variant.price.add
#
# @param ProductVariantPriceAdd $product_variant_price_add  (required)
{
    my $params = {
    'product_variant_price_add' => {
        data_type => 'ProductVariantPriceAdd',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_price_add' } = {
        summary => 'product.variant.price.add',
        params => $params,
        returns => 'CartValidate200Response',
        };
}
# @return CartValidate200Response
#
sub product_variant_price_add {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_price_add' is set
    unless (exists $args{'product_variant_price_add'}) {
      croak("Missing the required parameter 'product_variant_price_add' when calling product_variant_price_add");
    }

    # parse inputs
    my $_resource_path = '/product.variant.price.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_price_add'}) {
        $_body_data = $args{'product_variant_price_add'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CartValidate200Response', $response);
    return $_response_object;
}

#
# product_variant_price_delete
#
# product.variant.price.delete
#
# @param string $id Defines the variant where the price has to be deleted (required)
# @param string $product_id Product id (required)
# @param string $group_prices Defines variants&#39;s group prices (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Defines the variant where the price has to be deleted',
        required => '1',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Product id',
        required => '1',
    },
    'group_prices' => {
        data_type => 'string',
        description => 'Defines variants&#39;s group prices',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_price_delete' } = {
        summary => 'product.variant.price.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub product_variant_price_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling product_variant_price_delete");
    }

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling product_variant_price_delete");
    }

    # verify the required parameter 'group_prices' is set
    unless (exists $args{'group_prices'}) {
      croak("Missing the required parameter 'group_prices' when calling product_variant_price_delete");
    }

    # parse inputs
    my $_resource_path = '/product.variant.price.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'group_prices'}) {
        $query_params->{'group_prices'} = $self->{api_client}->to_query_value($args{'group_prices'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# product_variant_price_update
#
# product.variant.price.update
#
# @param ProductVariantPriceUpdate $product_variant_price_update  (required)
{
    my $params = {
    'product_variant_price_update' => {
        data_type => 'ProductVariantPriceUpdate',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_price_update' } = {
        summary => 'product.variant.price.update',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub product_variant_price_update {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_price_update' is set
    unless (exists $args{'product_variant_price_update'}) {
      croak("Missing the required parameter 'product_variant_price_update' when calling product_variant_price_update");
    }

    # parse inputs
    my $_resource_path = '/product.variant.price.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_price_update'}) {
        $_body_data = $args{'product_variant_price_update'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_variant_update
#
# product.variant.update
#
# @param ProductVariantUpdate $product_variant_update  (required)
{
    my $params = {
    'product_variant_update' => {
        data_type => 'ProductVariantUpdate',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_update' } = {
        summary => 'product.variant.update',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub product_variant_update {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_update' is set
    unless (exists $args{'product_variant_update'}) {
      croak("Missing the required parameter 'product_variant_update' when calling product_variant_update");
    }

    # parse inputs
    my $_resource_path = '/product.variant.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_update'}) {
        $_body_data = $args{'product_variant_update'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

#
# product_variant_update_batch
#
# product.variant.update.batch
#
# @param ProductVariantUpdateBatch $product_variant_update_batch  (required)
{
    my $params = {
    'product_variant_update_batch' => {
        data_type => 'ProductVariantUpdateBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'product_variant_update_batch' } = {
        summary => 'product.variant.update.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub product_variant_update_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'product_variant_update_batch' is set
    unless (exists $args{'product_variant_update_batch'}) {
      croak("Missing the required parameter 'product_variant_update_batch' when calling product_variant_update_batch");
    }

    # parse inputs
    my $_resource_path = '/product.variant.update.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'product_variant_update_batch'}) {
        $_body_data = $args{'product_variant_update_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

1;
