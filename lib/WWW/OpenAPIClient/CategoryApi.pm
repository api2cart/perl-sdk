=begin comment

API2Cart OpenAPI

API2Cart

The version of the OpenAPI document: 1.1
Contact: contact@api2cart.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::CategoryApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# category_add
#
# category.add
#
# @param string $name Defines category&#39;s name that has to be added (required)
# @param string $parent_id Adds categories specified by parent id (optional)
# @param string $stores_ids Create category in the stores that is specified by comma-separated stores&#39; id (optional)
# @param string $store_id Store Id (optional)
# @param string $lang_id Language id (optional)
# @param boolean $avail Defines category&#39;s visibility status (optional, default to true)
# @param int $sort_order Sort number in the list (optional, default to 0)
# @param string $created_time Entity&#39;s date creation (optional)
# @param string $modified_time Entity&#39;s date modification (optional)
# @param string $description Defines category&#39;s description (optional)
# @param string $short_description Defines short description (optional)
# @param string $meta_title Defines unique meta title for each entity (optional)
# @param string $meta_description Defines unique meta description of a entity (optional)
# @param string $meta_keywords Defines unique meta keywords for each entity (optional)
# @param string $seo_url Defines unique category&#39;s URL for SEO (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'Defines category&#39;s name that has to be added',
        required => '1',
    },
    'parent_id' => {
        data_type => 'string',
        description => 'Adds categories specified by parent id',
        required => '0',
    },
    'stores_ids' => {
        data_type => 'string',
        description => 'Create category in the stores that is specified by comma-separated stores&#39; id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'avail' => {
        data_type => 'boolean',
        description => 'Defines category&#39;s visibility status',
        required => '0',
    },
    'sort_order' => {
        data_type => 'int',
        description => 'Sort number in the list',
        required => '0',
    },
    'created_time' => {
        data_type => 'string',
        description => 'Entity&#39;s date creation',
        required => '0',
    },
    'modified_time' => {
        data_type => 'string',
        description => 'Entity&#39;s date modification',
        required => '0',
    },
    'description' => {
        data_type => 'string',
        description => 'Defines category&#39;s description',
        required => '0',
    },
    'short_description' => {
        data_type => 'string',
        description => 'Defines short description',
        required => '0',
    },
    'meta_title' => {
        data_type => 'string',
        description => 'Defines unique meta title for each entity',
        required => '0',
    },
    'meta_description' => {
        data_type => 'string',
        description => 'Defines unique meta description of a entity',
        required => '0',
    },
    'meta_keywords' => {
        data_type => 'string',
        description => 'Defines unique meta keywords for each entity',
        required => '0',
    },
    'seo_url' => {
        data_type => 'string',
        description => 'Defines unique category&#39;s URL for SEO',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_add' } = {
        summary => 'category.add',
        params => $params,
        returns => 'CategoryAdd200Response',
        };
}
# @return CategoryAdd200Response
#
sub category_add {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling category_add");
    }

    # parse inputs
    my $_resource_path = '/category.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'name'}) {
        $query_params->{'name'} = $self->{api_client}->to_query_value($args{'name'});
    }

    # query params
    if ( exists $args{'parent_id'}) {
        $query_params->{'parent_id'} = $self->{api_client}->to_query_value($args{'parent_id'});
    }

    # query params
    if ( exists $args{'stores_ids'}) {
        $query_params->{'stores_ids'} = $self->{api_client}->to_query_value($args{'stores_ids'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'avail'}) {
        $query_params->{'avail'} = $self->{api_client}->to_query_value($args{'avail'});
    }

    # query params
    if ( exists $args{'sort_order'}) {
        $query_params->{'sort_order'} = $self->{api_client}->to_query_value($args{'sort_order'});
    }

    # query params
    if ( exists $args{'created_time'}) {
        $query_params->{'created_time'} = $self->{api_client}->to_query_value($args{'created_time'});
    }

    # query params
    if ( exists $args{'modified_time'}) {
        $query_params->{'modified_time'} = $self->{api_client}->to_query_value($args{'modified_time'});
    }

    # query params
    if ( exists $args{'description'}) {
        $query_params->{'description'} = $self->{api_client}->to_query_value($args{'description'});
    }

    # query params
    if ( exists $args{'short_description'}) {
        $query_params->{'short_description'} = $self->{api_client}->to_query_value($args{'short_description'});
    }

    # query params
    if ( exists $args{'meta_title'}) {
        $query_params->{'meta_title'} = $self->{api_client}->to_query_value($args{'meta_title'});
    }

    # query params
    if ( exists $args{'meta_description'}) {
        $query_params->{'meta_description'} = $self->{api_client}->to_query_value($args{'meta_description'});
    }

    # query params
    if ( exists $args{'meta_keywords'}) {
        $query_params->{'meta_keywords'} = $self->{api_client}->to_query_value($args{'meta_keywords'});
    }

    # query params
    if ( exists $args{'seo_url'}) {
        $query_params->{'seo_url'} = $self->{api_client}->to_query_value($args{'seo_url'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAdd200Response', $response);
    return $_response_object;
}

#
# category_add_batch
#
# category.add.batch
#
# @param CategoryAddBatch $category_add_batch  (required)
{
    my $params = {
    'category_add_batch' => {
        data_type => 'CategoryAddBatch',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_add_batch' } = {
        summary => 'category.add.batch',
        params => $params,
        returns => 'CategoryAddBatch200Response',
        };
}
# @return CategoryAddBatch200Response
#
sub category_add_batch {
    my ($self, %args) = @_;

    # verify the required parameter 'category_add_batch' is set
    unless (exists $args{'category_add_batch'}) {
      croak("Missing the required parameter 'category_add_batch' when calling category_add_batch");
    }

    # parse inputs
    my $_resource_path = '/category.add.batch.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'category_add_batch'}) {
        $_body_data = $args{'category_add_batch'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryAddBatch200Response', $response);
    return $_response_object;
}

#
# category_assign
#
# category.assign
#
# @param string $product_id Defines category assign to the product, specified by product id (required)
# @param string $category_id Defines category assign, specified by category id (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'product_id' => {
        data_type => 'string',
        description => 'Defines category assign to the product, specified by product id',
        required => '1',
    },
    'category_id' => {
        data_type => 'string',
        description => 'Defines category assign, specified by category id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_assign' } = {
        summary => 'category.assign',
        params => $params,
        returns => 'CartConfigUpdate200Response',
        };
}
# @return CartConfigUpdate200Response
#
sub category_assign {
    my ($self, %args) = @_;

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling category_assign");
    }

    # verify the required parameter 'category_id' is set
    unless (exists $args{'category_id'}) {
      croak("Missing the required parameter 'category_id' when calling category_assign");
    }

    # parse inputs
    my $_resource_path = '/category.assign.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CartConfigUpdate200Response', $response);
    return $_response_object;
}

#
# category_count
#
# category.count
#
# @param string $parent_id Counts categories specified by parent id (optional)
# @param string $store_id Counts category specified by store id (optional)
# @param string $lang_id Counts category specified by language id (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param boolean $avail Defines category&#39;s visibility status (optional, default to true)
# @param string $product_type A categorization for the product (optional)
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $find_where Counts categories that are searched specified by field (optional)
# @param string $report_request_id Report request id (optional)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
{
    my $params = {
    'parent_id' => {
        data_type => 'string',
        description => 'Counts categories specified by parent id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Counts category specified by store id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Counts category specified by language id',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'avail' => {
        data_type => 'boolean',
        description => 'Defines category&#39;s visibility status',
        required => '0',
    },
    'product_type' => {
        data_type => 'string',
        description => 'A categorization for the product',
        required => '0',
    },
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Counts categories that are searched specified by field',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_count' } = {
        summary => 'category.count',
        params => $params,
        returns => 'CategoryCount200Response',
        };
}
# @return CategoryCount200Response
#
sub category_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/category.count.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'parent_id'}) {
        $query_params->{'parent_id'} = $self->{api_client}->to_query_value($args{'parent_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'avail'}) {
        $query_params->{'avail'} = $self->{api_client}->to_query_value($args{'avail'});
    }

    # query params
    if ( exists $args{'product_type'}) {
        $query_params->{'product_type'} = $self->{api_client}->to_query_value($args{'product_type'});
    }

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryCount200Response', $response);
    return $_response_object;
}

#
# category_delete
#
# category.delete
#
# @param string $id Defines category removal, specified by category id (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Defines category removal, specified by category id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_delete' } = {
        summary => 'category.delete',
        params => $params,
        returns => 'CategoryDelete200Response',
        };
}
# @return CategoryDelete200Response
#
sub category_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling category_delete");
    }

    # parse inputs
    my $_resource_path = '/category.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryDelete200Response', $response);
    return $_response_object;
}

#
# category_find
#
# category.find
#
# @param string $find_value Entity search that is specified by some value (required)
# @param string $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
# @param string $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
# @param string $store_id Store Id (optional)
# @param string $lang_id Language id (optional)
{
    my $params = {
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '1',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Entity search that is specified by the comma-separated unique fields',
        required => '0',
    },
    'find_params' => {
        data_type => 'string',
        description => 'Entity search that is specified by comma-separated parameters',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_find' } = {
        summary => 'category.find',
        params => $params,
        returns => 'CategoryFind200Response',
        };
}
# @return CategoryFind200Response
#
sub category_find {
    my ($self, %args) = @_;

    # verify the required parameter 'find_value' is set
    unless (exists $args{'find_value'}) {
      croak("Missing the required parameter 'find_value' when calling category_find");
    }

    # parse inputs
    my $_resource_path = '/category.find.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'find_params'}) {
        $query_params->{'find_params'} = $self->{api_client}->to_query_value($args{'find_params'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryFind200Response', $response);
    return $_response_object;
}

#
# category_image_add
#
# category.image.add
#
# @param string $category_id Defines category id where the image should be added (required)
# @param string $image_name Defines image&#39;s name (required)
# @param string $url Defines URL of the image that has to be added (required)
# @param string $type Defines image&#39;s types that are specified by comma-separated list (required)
# @param string $label Defines alternative text that has to be attached to the picture (optional)
# @param string $mime Mime type of image http://en.wikipedia.org/wiki/Internet_media_type. (optional)
# @param int $position Defines image’s position in the list (optional, default to 0)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'category_id' => {
        data_type => 'string',
        description => 'Defines category id where the image should be added',
        required => '1',
    },
    'image_name' => {
        data_type => 'string',
        description => 'Defines image&#39;s name',
        required => '1',
    },
    'url' => {
        data_type => 'string',
        description => 'Defines URL of the image that has to be added',
        required => '1',
    },
    'type' => {
        data_type => 'string',
        description => 'Defines image&#39;s types that are specified by comma-separated list',
        required => '1',
    },
    'label' => {
        data_type => 'string',
        description => 'Defines alternative text that has to be attached to the picture',
        required => '0',
    },
    'mime' => {
        data_type => 'string',
        description => 'Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.',
        required => '0',
    },
    'position' => {
        data_type => 'int',
        description => 'Defines image’s position in the list',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_image_add' } = {
        summary => 'category.image.add',
        params => $params,
        returns => 'CategoryImageAdd200Response',
        };
}
# @return CategoryImageAdd200Response
#
sub category_image_add {
    my ($self, %args) = @_;

    # verify the required parameter 'category_id' is set
    unless (exists $args{'category_id'}) {
      croak("Missing the required parameter 'category_id' when calling category_image_add");
    }

    # verify the required parameter 'image_name' is set
    unless (exists $args{'image_name'}) {
      croak("Missing the required parameter 'image_name' when calling category_image_add");
    }

    # verify the required parameter 'url' is set
    unless (exists $args{'url'}) {
      croak("Missing the required parameter 'url' when calling category_image_add");
    }

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling category_image_add");
    }

    # parse inputs
    my $_resource_path = '/category.image.add.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'image_name'}) {
        $query_params->{'image_name'} = $self->{api_client}->to_query_value($args{'image_name'});
    }

    # query params
    if ( exists $args{'url'}) {
        $query_params->{'url'} = $self->{api_client}->to_query_value($args{'url'});
    }

    # query params
    if ( exists $args{'label'}) {
        $query_params->{'label'} = $self->{api_client}->to_query_value($args{'label'});
    }

    # query params
    if ( exists $args{'mime'}) {
        $query_params->{'mime'} = $self->{api_client}->to_query_value($args{'mime'});
    }

    # query params
    if ( exists $args{'type'}) {
        $query_params->{'type'} = $self->{api_client}->to_query_value($args{'type'});
    }

    # query params
    if ( exists $args{'position'}) {
        $query_params->{'position'} = $self->{api_client}->to_query_value($args{'position'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryImageAdd200Response', $response);
    return $_response_object;
}

#
# category_image_delete
#
# category.image.delete
#
# @param string $category_id Defines category id where the image should be deleted (required)
# @param string $image_id Define image id (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'category_id' => {
        data_type => 'string',
        description => 'Defines category id where the image should be deleted',
        required => '1',
    },
    'image_id' => {
        data_type => 'string',
        description => 'Define image id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_image_delete' } = {
        summary => 'category.image.delete',
        params => $params,
        returns => 'AttributeDelete200Response',
        };
}
# @return AttributeDelete200Response
#
sub category_image_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'category_id' is set
    unless (exists $args{'category_id'}) {
      croak("Missing the required parameter 'category_id' when calling category_image_delete");
    }

    # verify the required parameter 'image_id' is set
    unless (exists $args{'image_id'}) {
      croak("Missing the required parameter 'image_id' when calling category_image_delete");
    }

    # parse inputs
    my $_resource_path = '/category.image.delete.json';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'image_id'}) {
        $query_params->{'image_id'} = $self->{api_client}->to_query_value($args{'image_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttributeDelete200Response', $response);
    return $_response_object;
}

#
# category_info
#
# category.info
#
# @param string $id Retrieves category&#39;s info specified by category id (required)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,parent_id,name,description')
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
# @param string $store_id Retrieves category info  specified by store id (optional)
# @param string $lang_id Retrieves category info  specified by language id (optional)
# @param string $schema_type The name of the requirements set for the provided schema. (optional)
# @param string $report_request_id Report request id (optional)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Retrieves category&#39;s info specified by category id',
        required => '1',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves category info  specified by store id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Retrieves category info  specified by language id',
        required => '0',
    },
    'schema_type' => {
        data_type => 'string',
        description => 'The name of the requirements set for the provided schema.',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_info' } = {
        summary => 'category.info',
        params => $params,
        returns => 'CategoryInfo200Response',
        };
}
# @return CategoryInfo200Response
#
sub category_info {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling category_info");
    }

    # parse inputs
    my $_resource_path = '/category.info.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'schema_type'}) {
        $query_params->{'schema_type'} = $self->{api_client}->to_query_value($args{'schema_type'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CategoryInfo200Response', $response);
    return $_response_object;
}

#
# category_list
#
# category.list
#
# @param int $start This parameter sets the number from which you want to get entities (optional, default to 0)
# @param int $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
# @param string $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
# @param string $parent_id Retrieves categories specified by parent id (optional)
# @param string $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,parent_id,name,description')
# @param string $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
# @param string $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
# @param string $store_id Retrieves categories specified by store id (optional)
# @param string $lang_id Retrieves categorys specified by language id (optional)
# @param string $created_from Retrieve entities from their creation date (optional)
# @param string $created_to Retrieve entities to their creation date (optional)
# @param string $modified_from Retrieve entities from their modification date (optional)
# @param string $modified_to Retrieve entities to their modification date (optional)
# @param boolean $avail Defines category&#39;s visibility status (optional, default to true)
# @param string $product_type A categorization for the product (optional)
# @param string $find_value Entity search that is specified by some value (optional)
# @param string $find_where Category search that is specified by field (optional)
# @param string $report_request_id Report request id (optional)
# @param boolean $disable_report_cache Disable report cache for current request (optional, default to false)
# @param boolean $disable_cache Disable cache for current request (optional, default to false)
{
    my $params = {
    'start' => {
        data_type => 'int',
        description => 'This parameter sets the number from which you want to get entities',
        required => '0',
    },
    'count' => {
        data_type => 'int',
        description => 'This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250',
        required => '0',
    },
    'page_cursor' => {
        data_type => 'string',
        description => 'Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)',
        required => '0',
    },
    'parent_id' => {
        data_type => 'string',
        description => 'Retrieves categories specified by parent id',
        required => '0',
    },
    'params' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'response_fields' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to retrieve',
        required => '0',
    },
    'exclude' => {
        data_type => 'string',
        description => 'Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Retrieves categories specified by store id',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Retrieves categorys specified by language id',
        required => '0',
    },
    'created_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their creation date',
        required => '0',
    },
    'created_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their creation date',
        required => '0',
    },
    'modified_from' => {
        data_type => 'string',
        description => 'Retrieve entities from their modification date',
        required => '0',
    },
    'modified_to' => {
        data_type => 'string',
        description => 'Retrieve entities to their modification date',
        required => '0',
    },
    'avail' => {
        data_type => 'boolean',
        description => 'Defines category&#39;s visibility status',
        required => '0',
    },
    'product_type' => {
        data_type => 'string',
        description => 'A categorization for the product',
        required => '0',
    },
    'find_value' => {
        data_type => 'string',
        description => 'Entity search that is specified by some value',
        required => '0',
    },
    'find_where' => {
        data_type => 'string',
        description => 'Category search that is specified by field',
        required => '0',
    },
    'report_request_id' => {
        data_type => 'string',
        description => 'Report request id',
        required => '0',
    },
    'disable_report_cache' => {
        data_type => 'boolean',
        description => 'Disable report cache for current request',
        required => '0',
    },
    'disable_cache' => {
        data_type => 'boolean',
        description => 'Disable cache for current request',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_list' } = {
        summary => 'category.list',
        params => $params,
        returns => 'ModelResponseCategoryList',
        };
}
# @return ModelResponseCategoryList
#
sub category_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/category.list.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'count'}) {
        $query_params->{'count'} = $self->{api_client}->to_query_value($args{'count'});
    }

    # query params
    if ( exists $args{'page_cursor'}) {
        $query_params->{'page_cursor'} = $self->{api_client}->to_query_value($args{'page_cursor'});
    }

    # query params
    if ( exists $args{'parent_id'}) {
        $query_params->{'parent_id'} = $self->{api_client}->to_query_value($args{'parent_id'});
    }

    # query params
    if ( exists $args{'params'}) {
        $query_params->{'params'} = $self->{api_client}->to_query_value($args{'params'});
    }

    # query params
    if ( exists $args{'response_fields'}) {
        $query_params->{'response_fields'} = $self->{api_client}->to_query_value($args{'response_fields'});
    }

    # query params
    if ( exists $args{'exclude'}) {
        $query_params->{'exclude'} = $self->{api_client}->to_query_value($args{'exclude'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'created_from'}) {
        $query_params->{'created_from'} = $self->{api_client}->to_query_value($args{'created_from'});
    }

    # query params
    if ( exists $args{'created_to'}) {
        $query_params->{'created_to'} = $self->{api_client}->to_query_value($args{'created_to'});
    }

    # query params
    if ( exists $args{'modified_from'}) {
        $query_params->{'modified_from'} = $self->{api_client}->to_query_value($args{'modified_from'});
    }

    # query params
    if ( exists $args{'modified_to'}) {
        $query_params->{'modified_to'} = $self->{api_client}->to_query_value($args{'modified_to'});
    }

    # query params
    if ( exists $args{'avail'}) {
        $query_params->{'avail'} = $self->{api_client}->to_query_value($args{'avail'});
    }

    # query params
    if ( exists $args{'product_type'}) {
        $query_params->{'product_type'} = $self->{api_client}->to_query_value($args{'product_type'});
    }

    # query params
    if ( exists $args{'find_value'}) {
        $query_params->{'find_value'} = $self->{api_client}->to_query_value($args{'find_value'});
    }

    # query params
    if ( exists $args{'find_where'}) {
        $query_params->{'find_where'} = $self->{api_client}->to_query_value($args{'find_where'});
    }

    # query params
    if ( exists $args{'report_request_id'}) {
        $query_params->{'report_request_id'} = $self->{api_client}->to_query_value($args{'report_request_id'});
    }

    # query params
    if ( exists $args{'disable_report_cache'}) {
        $query_params->{'disable_report_cache'} = $self->{api_client}->to_query_value($args{'disable_report_cache'});
    }

    # query params
    if ( exists $args{'disable_cache'}) {
        $query_params->{'disable_cache'} = $self->{api_client}->to_query_value($args{'disable_cache'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ModelResponseCategoryList', $response);
    return $_response_object;
}

#
# category_unassign
#
# category.unassign
#
# @param string $category_id Defines category unassign, specified by category id (required)
# @param string $product_id Defines category unassign to the product, specified by product id (required)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'category_id' => {
        data_type => 'string',
        description => 'Defines category unassign, specified by category id',
        required => '1',
    },
    'product_id' => {
        data_type => 'string',
        description => 'Defines category unassign to the product, specified by product id',
        required => '1',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_unassign' } = {
        summary => 'category.unassign',
        params => $params,
        returns => 'CartConfigUpdate200Response',
        };
}
# @return CartConfigUpdate200Response
#
sub category_unassign {
    my ($self, %args) = @_;

    # verify the required parameter 'category_id' is set
    unless (exists $args{'category_id'}) {
      croak("Missing the required parameter 'category_id' when calling category_unassign");
    }

    # verify the required parameter 'product_id' is set
    unless (exists $args{'product_id'}) {
      croak("Missing the required parameter 'product_id' when calling category_unassign");
    }

    # parse inputs
    my $_resource_path = '/category.unassign.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'category_id'}) {
        $query_params->{'category_id'} = $self->{api_client}->to_query_value($args{'category_id'});
    }

    # query params
    if ( exists $args{'product_id'}) {
        $query_params->{'product_id'} = $self->{api_client}->to_query_value($args{'product_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CartConfigUpdate200Response', $response);
    return $_response_object;
}

#
# category_update
#
# category.update
#
# @param string $id Defines category update specified by category id (required)
# @param string $name Defines new category’s name (optional)
# @param string $parent_id Defines new parent category id (optional)
# @param string $stores_ids Update category in the stores that is specified by comma-separated stores&#39; id (optional)
# @param boolean $avail Defines category&#39;s visibility status (optional)
# @param int $sort_order Sort number in the list (optional)
# @param string $modified_time Entity&#39;s date modification (optional)
# @param string $description Defines new category&#39;s description (optional)
# @param string $short_description Defines short description (optional)
# @param string $meta_title Defines unique meta title for each entity (optional)
# @param string $meta_description Defines unique meta description of a entity (optional)
# @param string $meta_keywords Defines unique meta keywords for each entity (optional)
# @param string $seo_url Defines unique category&#39;s URL for SEO (optional)
# @param string $lang_id Language id (optional)
# @param string $store_id Store Id (optional)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'Defines category update specified by category id',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'Defines new category’s name',
        required => '0',
    },
    'parent_id' => {
        data_type => 'string',
        description => 'Defines new parent category id',
        required => '0',
    },
    'stores_ids' => {
        data_type => 'string',
        description => 'Update category in the stores that is specified by comma-separated stores&#39; id',
        required => '0',
    },
    'avail' => {
        data_type => 'boolean',
        description => 'Defines category&#39;s visibility status',
        required => '0',
    },
    'sort_order' => {
        data_type => 'int',
        description => 'Sort number in the list',
        required => '0',
    },
    'modified_time' => {
        data_type => 'string',
        description => 'Entity&#39;s date modification',
        required => '0',
    },
    'description' => {
        data_type => 'string',
        description => 'Defines new category&#39;s description',
        required => '0',
    },
    'short_description' => {
        data_type => 'string',
        description => 'Defines short description',
        required => '0',
    },
    'meta_title' => {
        data_type => 'string',
        description => 'Defines unique meta title for each entity',
        required => '0',
    },
    'meta_description' => {
        data_type => 'string',
        description => 'Defines unique meta description of a entity',
        required => '0',
    },
    'meta_keywords' => {
        data_type => 'string',
        description => 'Defines unique meta keywords for each entity',
        required => '0',
    },
    'seo_url' => {
        data_type => 'string',
        description => 'Defines unique category&#39;s URL for SEO',
        required => '0',
    },
    'lang_id' => {
        data_type => 'string',
        description => 'Language id',
        required => '0',
    },
    'store_id' => {
        data_type => 'string',
        description => 'Store Id',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'category_update' } = {
        summary => 'category.update',
        params => $params,
        returns => 'AccountConfigUpdate200Response',
        };
}
# @return AccountConfigUpdate200Response
#
sub category_update {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling category_update");
    }

    # parse inputs
    my $_resource_path = '/category.update.json';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    # query params
    if ( exists $args{'name'}) {
        $query_params->{'name'} = $self->{api_client}->to_query_value($args{'name'});
    }

    # query params
    if ( exists $args{'parent_id'}) {
        $query_params->{'parent_id'} = $self->{api_client}->to_query_value($args{'parent_id'});
    }

    # query params
    if ( exists $args{'stores_ids'}) {
        $query_params->{'stores_ids'} = $self->{api_client}->to_query_value($args{'stores_ids'});
    }

    # query params
    if ( exists $args{'avail'}) {
        $query_params->{'avail'} = $self->{api_client}->to_query_value($args{'avail'});
    }

    # query params
    if ( exists $args{'sort_order'}) {
        $query_params->{'sort_order'} = $self->{api_client}->to_query_value($args{'sort_order'});
    }

    # query params
    if ( exists $args{'modified_time'}) {
        $query_params->{'modified_time'} = $self->{api_client}->to_query_value($args{'modified_time'});
    }

    # query params
    if ( exists $args{'description'}) {
        $query_params->{'description'} = $self->{api_client}->to_query_value($args{'description'});
    }

    # query params
    if ( exists $args{'short_description'}) {
        $query_params->{'short_description'} = $self->{api_client}->to_query_value($args{'short_description'});
    }

    # query params
    if ( exists $args{'meta_title'}) {
        $query_params->{'meta_title'} = $self->{api_client}->to_query_value($args{'meta_title'});
    }

    # query params
    if ( exists $args{'meta_description'}) {
        $query_params->{'meta_description'} = $self->{api_client}->to_query_value($args{'meta_description'});
    }

    # query params
    if ( exists $args{'meta_keywords'}) {
        $query_params->{'meta_keywords'} = $self->{api_client}->to_query_value($args{'meta_keywords'});
    }

    # query params
    if ( exists $args{'seo_url'}) {
        $query_params->{'seo_url'} = $self->{api_client}->to_query_value($args{'seo_url'});
    }

    # query params
    if ( exists $args{'lang_id'}) {
        $query_params->{'lang_id'} = $self->{api_client}->to_query_value($args{'lang_id'});
    }

    # query params
    if ( exists $args{'store_id'}) {
        $query_params->{'store_id'} = $self->{api_client}->to_query_value($args{'store_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(StoreKeyAuth ApiKeyAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AccountConfigUpdate200Response', $response);
    return $_response_object;
}

1;
